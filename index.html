<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Milestones: The 10th Birthday</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #2c3e50;
            font-family: 'Nunito', sans-serif;
            touch-action: none;
            /* Prevent pull-to-refresh on mobile */
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* HUD */
        #hud {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            color: white;
            text-shadow: 2px 2px 0 #000;
            font-family: 'Fredoka One', cursive;
            font-size: 24px;
            pointer-events: none;
        }

        /* Screens (Start, Game Over, etc) */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            pointer-events: auto;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-family: 'Fredoka One', cursive;
            font-size: 48px;
            margin-bottom: 10px;
            color: #FFD700;
            text-shadow: 3px 3px 0 #d35400;
            text-align: center;
            width: 100%;
        }

        p {
            font-size: 18px;
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
            margin-bottom: 30px;
            margin-left: auto;
            margin-right: auto;
        }

        .btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            font-family: 'Fredoka One', cursive;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 6px 0 #c0392b;
            transition: transform 0.1s;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #c0392b;
        }

        /* Mobile Controls */
        #controls {
            display: none;
            /* Shown via JS on touch devices */
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            justify-content: space-between;
            pointer-events: auto;
            padding-bottom: 40px;
        }

        .control-btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 30px;
            user-select: none;
            backdrop-filter: blur(4px);
        }

        .control-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }

        .d-pad {
            display: flex;
            gap: 20px;
        }

        /* Final Message styling - UPGRADED for Robust Centering */
        #final-message {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            transform: translateY(-50%);
            /* Vertical centering */

            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;

            text-align: center;
            color: white;
            font-family: 'Fredoka One', cursive;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            /* KEY FIX: Don't block clicks on the overlay container */
            opacity: 0;
            transition: opacity 2s;
            z-index: 20;
        }

        /* Gift Animation */
        @keyframes bounceGift {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        #gift-container {
            cursor: pointer;
            margin: 20px 0;
            transition: transform 0.2s;
            pointer-events: auto;
            /* KEY FIX: Only the gift itself captures clicks */
        }

        #gift-container:hover {
            transform: scale(1.05);
        }

        #gift-box {
            font-size: 100px;
            animation: bounceGift 1.5s infinite;
            filter: drop-shadow(0 0 10px gold);
        }

        #click-hint {
            font-size: 24px;
            color: #ffeaa7;
            animation: blink 1s infinite alternate;
        }

        @keyframes blink {
            from {
                opacity: 0.5;
            }

            to {
                opacity: 1;
            }
        }

        #surprise-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from {
                transform: scale(0);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        #surprise-text {
            color: #FFD700;
            font-size: 40px;
            text-shadow: 2px 2px #e91e63;
            margin: 20px 0;
            line-height: 1.2;
        }

        #doll-house-icon {
            font-size: 80px;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 15px #e91e63);
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="hud">
            <div id="level-display">Age: 1</div>
            <div id="score-display">Memories: 0/3</div>
        </div>

        <div id="final-message">
            <h1 id="bday-header" style="color: #fff; font-size: 48px; margin-bottom: 10px;">Happy 10th Birthday Sakina
                !!!</h1>

            <!-- Gift Section -->
            <div id="gift-container" onclick="openGift()">
                <div id="gift-box">üéÅ</div>
                <div id="click-hint">Click to Open Gift!</div>
            </div>

            <!-- Surprise Reveal Section (Hidden initially) -->
            <div id="surprise-container" class="hidden">
                <div id="doll-house-icon">üè∞</div>
                <div id="surprise-text">Surprise Sakina you unlocked a doll house !!!</div>
            </div>

            <!-- Family Quote (Hidden initially) -->
            <p id="family-quote" class="hidden" style="font-size: 24px; color: #ffeaa7; margin-top: 20px;">"We will
                always be there for your every milestone."</p>
        </div>

        <div id="controls">
            <div class="d-pad">
                <div class="control-btn" id="btn-left">‚Üê</div>
                <div class="control-btn" id="btn-right">‚Üí</div>
            </div>
            <div class="control-btn" id="btn-flap" style="width: 100px; border-radius: 30px;">FLAP</div>
        </div>
    </div>

    <!-- START SCREEN -->
    <div id="start-screen" class="screen">
        <h1>MILESTONES</h1>
        <p>Help her fly through the years. Collect memories (stars) to grow up.<br>Tap FLAP to fly. Avoid the obstacles!
        </p>
        <button class="btn" id="start-btn">Start Journey</button>
    </div>

    <!-- LEVEL COMPLETE SCREEN -->
    <div id="level-screen" class="screen hidden">
        <h1 id="level-title">Age 1 Complete!</h1>
        <p>Ready for the next year?</p>
        <button class="btn" id="next-level-btn">Grow Up</button>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="game-over-screen" class="screen hidden">
        <h1>Ouch!</h1>
        <p>Don't worry, we can always try again.</p>
        <button class="btn" id="retry-btn">Try Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- CUSTOM PHOTOS CONFIGURATION ---
        // REPLACE these URLs with your own image links!
        const girlImg = new Image();
        girlImg.crossOrigin = "Anonymous"; // Try to enable CORS if needed
        girlImg.src = 'https://raw.githubusercontent.com/prateektalesara/mcq-engine/refs/heads/game/sk-i.png';

        const momImg = new Image();
        momImg.crossOrigin = "Anonymous";
        momImg.src = 'https://raw.githubusercontent.com/prateektalesara/mcq-engine/refs/heads/game/mom-i.png';

        const dadImg = new Image();
        dadImg.crossOrigin = "Anonymous";
        dadImg.src = 'https://raw.githubusercontent.com/prateektalesara/mcq-engine/refs/heads/game/dad-i.png';
        // ------------------------------------

        // Screens & UI
        const startScreen = document.getElementById('start-screen');
        const levelScreen = document.getElementById('level-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const levelTitle = document.getElementById('level-title');
        const hudLevel = document.getElementById('level-display');
        const hudScore = document.getElementById('score-display');
        const controls = document.getElementById('controls');
        const finalMessage = document.getElementById('final-message');
        const giftContainer = document.getElementById('gift-container');
        const surpriseContainer = document.getElementById('surprise-container');
        const familyQuote = document.getElementById('family-quote');

        // Game State
        let gameState = 'START'; // START, PLAYING, LEVEL_END, GAMEOVER, CUTSCENE, ENDED
        let level = 1;
        let maxLevels = 10; // Change this to 2 to test the ending!
        let frames = 0;
        let animationFrameId;

        // Time management
        let lastTime = 0;
        let fireworkInterval = null; // Store interval ID to prevent leaks

        // Physics
        const GRAVITY = 0.28;
        const FLAP_FORCE = -8.0;
        const MOVE_SPEED = 0.4;
        const MAX_H_SPEED = 6;
        const FRICTION = 0.96;

        // Input
        const keys = {
            ArrowLeft: false,
            ArrowRight: false,
            Space: false,
            ArrowUp: false
        };

        // Entities
        let player;
        let obstacles = [];
        let collectibles = [];
        let particles = [];
        let portal;
        let parents = [];
        let cake;

        // Colors
        const levelColors = [
            '#87CEEB', '#AED581', '#4DB6AC', '#FFF176', '#FFB74D',
            '#F06292', '#BA68C8', '#7986CB', '#4FC3F7', '#2c3e50'
        ];

        // Resize
        function resize() {
            if (Math.abs(canvas.width - window.innerWidth) > 10 || Math.abs(canvas.height - window.innerHeight) > 10) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                    controls.style.display = 'flex';
                }
                if (gameState !== 'START') draw();
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // ------------------ CLASSES ------------------

        class Player {
            constructor() {
                this.x = 100;
                this.y = canvas.height - 150;
                this.vx = 0;
                this.vy = 0;
                this.radius = 15;
                this.width = 30;
                this.height = 40;
                this.facingRight = true;
                this.balloons = 2;
                this.flapCooldown = 0;
            }

            update(dt) {
                if (gameState === 'CUTSCENE' || gameState === 'ENDED') {
                    this.cutsceneBehavior(dt);
                    return;
                }

                // Physics
                this.vy += GRAVITY * dt;
                this.vx *= Math.pow(FRICTION, dt);
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Inputs
                if (keys.ArrowRight) {
                    this.vx += MOVE_SPEED * dt;
                    this.facingRight = true;
                }
                if (keys.ArrowLeft) {
                    this.vx -= MOVE_SPEED * dt;
                    this.facingRight = false;
                }

                if (this.vx > MAX_H_SPEED) this.vx = MAX_H_SPEED;
                if (this.vx < -MAX_H_SPEED) this.vx = -MAX_H_SPEED;

                if (this.y + this.height / 2 > canvas.height - 20) {
                    this.y = canvas.height - 20 - this.height / 2;
                    this.vy = 0;
                }
                if (this.y < 0) {
                    this.y = 0;
                    this.vy = 0;
                }
                if (this.x > canvas.width) this.x = 0;
                if (this.x < 0) this.x = canvas.width;

                if (this.flapCooldown > 0) this.flapCooldown -= 1 * dt;
            }

            flap() {
                this.vy = FLAP_FORCE;
                createParticles(this.x, this.y + 20, 3, '#fff');
            }

            cutsceneBehavior(dt) {
                this.vy += GRAVITY * dt;
                this.vx *= 0.8;
                this.y += this.vy * dt;
                this.x += this.vx * dt;

                if (this.y + this.height / 2 > canvas.height - 50) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Balloons
                if (this.balloons > 0) {
                    ctx.strokeStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(0, -20);
                    ctx.lineTo(-10, -50);
                    ctx.moveTo(0, -20);
                    ctx.lineTo(10, -50);
                    ctx.stroke();

                    // Balloon 1
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.ellipse(-10, -55, 12, 15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.ellipse(-13, -58, 3, 5, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Balloon 2
                    ctx.fillStyle = '#3498db';
                    ctx.beginPath();
                    ctx.ellipse(10, -55, 12, 15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.ellipse(7, -58, 3, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw Girl Body (Vector)
                ctx.fillStyle = '#9b59b6';
                ctx.beginPath();
                ctx.moveTo(0, -10);
                ctx.lineTo(-10, 20);
                ctx.lineTo(10, 20);
                ctx.fill();

                // Draw Custom Face (Girl)
                try {
                    const size = 60; // Increased size to 60 (Double original 30)
                    ctx.save();
                    ctx.translate(0, -30); // Adjusted Y translation for larger head

                    // Clip to Circle
                    ctx.beginPath();
                    ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.clip();

                    if (!this.facingRight) {
                        ctx.scale(-1, 1);
                    }

                    // Zoom Hack: Draw image 1.5x larger to crop out white borders
                    const zoom = 1.5;
                    ctx.drawImage(girlImg, -size * zoom / 2, -size * zoom / 2, size * zoom, size * zoom);

                    ctx.restore();

                } catch (e) {
                    ctx.fillStyle = '#ffe0b2';
                    ctx.beginPath();
                    ctx.arc(0, -15, 10, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        class Obstacle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.startX = x;
                this.startY = y;
                this.type = type;
                this.size = 20;
                this.speed = Math.random() * 2 + 1;
                this.dir = 1;
                this.angle = 0;
            }

            update(dt) {
                if (this.type === 'horizontal') {
                    this.x += (this.speed * this.dir) * dt;
                    if (this.x > canvas.width + 50) this.x = -50;
                    if (this.x < -50) this.x = canvas.width + 50;
                } else if (this.type === 'vertical') {
                    this.y = this.startY + Math.sin(Date.now() * 0.002) * 50;
                } else if (this.type === 'circle') {
                    this.angle += 0.05 * dt;
                    this.x = this.startX + Math.cos(this.angle) * 50;
                    this.y = this.startY + Math.sin(this.angle) * 50;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = '#546e7a';
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#37474f';
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    let a = (Math.PI * 2 / 8) * i + frames * 0.05;
                    let sx = Math.cos(a) * (this.size + 5);
                    let sy = Math.sin(a) * (this.size + 5);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(sx, sy);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        class Collectible {
            constructor(x, y) {
                this.x = x;
                this.baseY = y;
                this.y = y;
                this.size = 15;
                this.collected = false;
                this.floatOffset = Math.random() * Math.PI * 2;
            }

            update(dt) {
                this.y = this.baseY + Math.sin(Date.now() * 0.003 + this.floatOffset) * 10;
            }

            draw() {
                if (this.collected) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    ctx.lineTo(Math.cos((18 + i * 72) * 0.0174533) * this.size,
                        -Math.sin((18 + i * 72) * 0.0174533) * this.size);
                    ctx.lineTo(Math.cos((54 + i * 72) * 0.0174533) * (this.size / 2),
                        -Math.sin((54 + i * 72) * 0.0174533) * (this.size / 2));
                }
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#f39c12';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
            }
        }

        class Portal {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.active = false;
                this.radius = 0;
            }

            update(dt) {
                if (this.active && this.radius < 40) {
                    this.radius += 2 * dt;
                }
            }

            draw() {
                if (!this.active) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(frames * 0.05);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fill();
                ctx.restore();

                if (this.active) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '16px Fredoka One';
                    ctx.textAlign = 'center';
                    ctx.fillText('Next Year', this.x, this.y - 50);
                }
            }
        }

        class Particle {
            constructor(x, y, color, type = 'normal') {
                this.x = x;
                this.y = y;
                this.color = color;
                this.type = type;
                this.life = 100;

                if (type === 'firework') {
                    // Explode outward in circle
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 6 + 2;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.size = Math.random() * 3 + 1;
                    this.decay = Math.random() * 1.5 + 0.5; // Random fade speed
                } else {
                    // Standard dust
                    this.vx = (Math.random() - 0.5) * 6;
                    this.vy = (Math.random() - 0.5) * 6;
                    this.size = Math.random() * 5 + 2;
                    this.decay = 2;
                }
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                if (this.type === 'firework') {
                    this.vy += 0.1 * dt; // Add Gravity to sparks
                    this.vx *= 0.95; // Air resistance
                    this.vy *= 0.95;
                }

                this.life -= this.decay * dt;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.life / 100);

                if (this.type === 'firework') {
                    // Performance fix: Use 'lighter' blend but avoid heavy shadowBlur
                    ctx.globalCompositeOperation = 'lighter';
                }

                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // ------------------ GAME LOGIC ------------------

        function getOrdinal(n) {
            var s = ["th", "st", "nd", "rd"];
            var v = n % 100;
            return n + (s[(v - 20) % 10] || s[v] || s[0]);
        }

        function initLevel(lvl) {
            level = lvl;
            player = new Player();
            particles = [];
            obstacles = [];
            collectibles = [];
            parents = [];

            // Safety: Clear previous firework interval to prevent stacking/leaks
            if (fireworkInterval) {
                clearInterval(fireworkInterval);
                fireworkInterval = null;
            }

            hudLevel.innerText = `Age: ${level}`;
            hudScore.innerText = `Memories: 0/3`;
            finalMessage.style.opacity = 0;

            // Reset Final Message State
            // KEY FIX: Completely hide giftContainer so it doesn't block play area
            giftContainer.style.display = 'none';

            giftContainer.classList.remove('hidden'); // Legacy remove (can be ignored)
            surpriseContainer.classList.add('hidden');
            familyQuote.classList.add('hidden');

            if (level === maxLevels) {
                initBirthdayLevel();
            } else {
                initStandardLevel(lvl);
            }

            gameState = 'PLAYING';
        }

        function initStandardLevel(lvl) {
            portal = new Portal(canvas.width - 100, canvas.height - 100);

            const count = 3;
            for (let i = 0; i < count; i++) {
                let cx = 200 + Math.random() * (canvas.width - 300);
                let cy = 50 + Math.random() * (canvas.height - 150);
                collectibles.push(new Collectible(cx, cy));
            }

            let obsCount = (lvl - 1) * 2;
            if (obsCount > 15) obsCount = 15;

            for (let i = 0; i < obsCount; i++) {
                let ox = 300 + Math.random() * (canvas.width - 400);
                let oy = Math.random() * (canvas.height - 100);
                let type = 'static';

                if (lvl > 3) type = Math.random() > 0.5 ? 'horizontal' : 'static';
                if (lvl > 6) type = Math.random() > 0.5 ? 'vertical' : 'horizontal';
                if (lvl > 8) type = 'circle';

                obstacles.push(new Obstacle(ox, oy, type));
            }
        }

        function initBirthdayLevel() {
            collectibles = [];
            obstacles = [];
            portal = null;
            cake = { x: canvas.width / 2, y: canvas.height - 60, w: 100, h: 60 };
            parents.push({ x: canvas.width / 2 - 80, y: canvas.height - 110, role: 'dad' });
            parents.push({ x: canvas.width / 2 + 80, y: canvas.height - 110, role: 'mom' });

            // HUD Update: Show "Memories: A lot"
            hudScore.innerText = "Memories: A lot";

            // Fix grammar: 1st, 2nd, 3rd, 10th
            const bdayHeader = document.getElementById('bday-header');
            if (bdayHeader) {
                bdayHeader.innerText = `Happy ${getOrdinal(maxLevels)} Birthday Sakina !!!`;
            }
        }

        function update(dt) {
            if (gameState !== 'PLAYING' && gameState !== 'CUTSCENE' && gameState !== 'ENDED') return;

            frames++;
            player.update(dt);

            obstacles.forEach(o => o.update(dt));
            collectibles.forEach(c => c.update(dt));

            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.update(dt);
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            if (portal) portal.update(dt);

            if (gameState === 'PLAYING') {
                checkCollisions();
            }

            if (level === maxLevels && gameState === 'PLAYING') {
                let dx = player.x - cake.x;
                let dy = player.y - (canvas.height - 50);
                if (Math.abs(dx) < 150 && player.y > canvas.height - 150) {
                    startEndingCutscene();
                }
            }
        }

        function checkCollisions() {
            let collectedCount = 0;
            collectibles.forEach(c => {
                let dx = player.x - c.x;
                let dy = player.y - c.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < player.radius + c.size && !c.collected) {
                    c.collected = true;
                    createParticles(c.x, c.y, 10, '#f1c40f');
                }
                if (c.collected) collectedCount++;
            });

            hudScore.innerText = `Memories: ${collectedCount}/3`;

            if (portal && collectedCount === 3 && !portal.active) {
                portal.active = true;
                createParticles(portal.x, portal.y, 20, '#fff');
            }

            if (portal && portal.active) {
                let dx = player.x - portal.x;
                let dy = player.y - portal.y;
                if (Math.sqrt(dx * dx + dy * dy) < 40) {
                    completeLevel();
                }
            }

            obstacles.forEach(o => {
                let dx = player.x - o.x;
                let dy = player.y - o.y;
                if (Math.sqrt(dx * dx + dy * dy) < player.radius + o.size - 5) {
                    gameOver();
                }
            });
        }

        function createParticles(x, y, count, color, type) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, type));
            }
        }

        function draw() {
            let bgIndex = level - 1;
            if (bgIndex >= levelColors.length) bgIndex = levelColors.length - 1;
            ctx.fillStyle = levelColors[bgIndex];
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, canvas.height - 20, canvas.width, 20);

            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(100 + Math.sin(frames * 0.01) * 50, 100, 40, 0, Math.PI * 2);
            ctx.arc(150 + Math.sin(frames * 0.01) * 50, 90, 50, 0, Math.PI * 2);
            ctx.arc(200 + Math.sin(frames * 0.01) * 50, 100, 40, 0, Math.PI * 2);
            ctx.fill();

            if (portal) portal.draw();
            obstacles.forEach(o => o.draw());
            collectibles.forEach(c => c.draw());

            if (level === maxLevels) {
                drawBirthdayScene();
            }

            player.draw();
            particles.forEach(p => p.draw());
        }

        function drawBirthdayScene() {
            parents.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);

                try {
                    // Draw Body (Restored)
                    ctx.fillStyle = p.role === 'dad' ? '#34495e' : '#e91e63';
                    ctx.fillRect(-15, 0, 30, 90);

                    // Draw Avatar Head
                    const size = 100; // Increased size to 100 (Doubled from 50ish range)
                    ctx.save();
                    ctx.translate(0, -50); // Adjusted Y translation for significantly larger head

                    // Clip to Circle
                    ctx.beginPath();
                    ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.clip();

                    // Zoom Hack: Draw image 1.5x larger to crop out white borders
                    const zoom = 1.5;
                    if (p.role === 'dad') {
                        ctx.drawImage(dadImg, -size * zoom / 2, -size * zoom / 2, size * zoom, size * zoom);
                    } else {
                        ctx.drawImage(momImg, -size * zoom / 2, -size * zoom / 2, size * zoom, size * zoom);
                    }

                    ctx.restore();
                } catch (e) {
                    ctx.fillStyle = p.role === 'dad' ? '#34495e' : '#e91e63';
                    ctx.fillRect(-15, 0, 30, 90);
                    ctx.fillStyle = '#ffe0b2';
                    ctx.beginPath();
                    ctx.arc(0, -15, 20, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            });

            ctx.save();
            ctx.translate(cake.x, cake.y);
            ctx.fillStyle = '#8e44ad';
            ctx.fillRect(-60, 40, 120, 10);
            ctx.fillStyle = '#fff';
            ctx.fillRect(-50, 0, 100, 40);
            ctx.fillStyle = '#ffc0cb';
            ctx.fillRect(-50, 0, 100, 10);

            for (let i = 0; i < 10; i++) {
                let cx = -40 + i * 9;
                ctx.fillStyle = '#f1c40f';
                ctx.fillRect(cx, -15, 4, 15);
                if (frames % 10 < 5) {
                    ctx.fillStyle = '#e67e22';
                    ctx.beginPath();
                    ctx.arc(cx + 2, -18, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            gameOverScreen.classList.remove('hidden');
        }

        function completeLevel() {
            gameState = 'LEVEL_END';
            if (level < maxLevels) {
                levelTitle.innerText = `Age ${level} Complete!`;
                levelScreen.classList.remove('hidden');
            }
        }

        function nextLevel() {
            level++;
            levelScreen.classList.add('hidden');
            initLevel(level);
        }

        function startEndingCutscene() {
            gameState = 'CUTSCENE';
            keys.ArrowLeft = false;
            keys.ArrowRight = false;
            keys.Space = false;

            let interval = setInterval(() => {
                if (gameState === 'ENDED') {
                    clearInterval(interval);
                    return;
                }

                let dx = player.x - cake.x;
                if (Math.abs(dx) > 10) {
                    player.x -= Math.sign(dx) * 1;
                    player.facingRight = dx < 0;
                    if (frames % 20 === 0 && player.y > canvas.height - 40) player.vy = -3;
                } else {
                    clearInterval(interval);
                    triggerFinale();
                }
            }, 16);
        }

        function triggerFinale() {
            gameState = 'ENDED';
            player.vx = 0;
            player.vy = 0;
            player.y = canvas.height - 20 - player.height / 2;

            parents[0].x = player.x - 40;
            parents[1].x = player.x + 40;

            // Initial explosion
            for (let i = 0; i < 60; i++) {
                setTimeout(() => {
                    createParticles(Math.random() * canvas.width, Math.random() * canvas.height / 2 + 50, 40, getRandomColor(), 'firework');
                }, i * 50);
            }

            finalMessage.style.opacity = 1;

            // KEY FIX: Make the Gift Visible specifically now
            giftContainer.style.display = 'block';

            // Continuous fireworks loop
            fireworkInterval = setInterval(() => {
                // Safety Cap: Don't spawn if too many particles are on screen
                if (particles.length > 400) return;

                // Random explosion position
                let ex = Math.random() * (canvas.width * 0.8) + (canvas.width * 0.1);
                let ey = Math.random() * (canvas.height * 0.4) + 50;
                // Reduced particles per explosion for performance
                createParticles(ex, ey, 30, getRandomColor(), 'firework');
            }, 800); // Slightly slower frequency
        }

        // --- NEW GIFT REVEAL FUNCTION ---
        function openGift() {
            const giftBox = document.getElementById('gift-container');
            const surprise = document.getElementById('surprise-container');
            const quote = document.getElementById('family-quote');

            // Hide Gift
            giftBox.style.display = 'none';

            // Explosion Effect at center
            createParticles(canvas.width / 2, canvas.height / 2, 100, '#FFD700', 'firework');
            createParticles(canvas.width / 2, canvas.height / 2, 50, '#e91e63', 'firework');

            // Show Surprise
            surprise.classList.remove('hidden');

            // Fade in Quote after short delay
            setTimeout(() => {
                quote.classList.remove('hidden');
                quote.style.opacity = 1;
            }, 1000);
        }

        function getRandomColor() {
            const colors = ['#e74c3c', '#e67e22', '#f1c40f', '#2ecc71', '#3498db', '#9b59b6'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        window.addEventListener('keydown', e => {
            if (e.code === 'ArrowLeft') keys.ArrowLeft = true;
            if (e.code === 'ArrowRight') keys.ArrowRight = true;
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault(); // Prevent scrolling/button clicking
                if (!keys.Space) player.flap();
                keys.Space = true;
            }
        });

        window.addEventListener('keyup', e => {
            if (e.code === 'ArrowLeft') keys.ArrowLeft = false;
            if (e.code === 'ArrowRight') keys.ArrowRight = false;
            if (e.code === 'Space' || e.code === 'ArrowUp') keys.Space = false;
        });

        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnFlap = document.getElementById('btn-flap');

        const addTouch = (elem, code) => {
            elem.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (code === 'Space') player.flap();
                keys[code] = true;
            }, { passive: false });
            elem.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[code] = false;
            }, { passive: false });
        };

        addTouch(btnLeft, 'ArrowLeft');
        addTouch(btnRight, 'ArrowRight');
        addTouch(btnFlap, 'Space');

        document.getElementById('start-btn').addEventListener('click', (e) => {
            e.target.blur(); // Remove focus
            startScreen.classList.add('hidden');
            initLevel(1);

            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            lastTime = performance.now();
            loop(lastTime);
        });

        document.getElementById('next-level-btn').addEventListener('click', (e) => {
            e.target.blur();
            nextLevel();
        });

        document.getElementById('retry-btn').addEventListener('click', (e) => {
            e.target.blur();
            gameOverScreen.classList.add('hidden');
            initLevel(level);
        });

        function loop(timestamp) {
            // Calculate delta time (dt)
            // Divide by 16.666 to normalize to ~60FPS
            // (16.66ms is one frame at 60FPS)
            const dt = (timestamp - lastTime) / 16.666;
            lastTime = timestamp;

            // Cap dt to prevent huge jumps if tab is inactive
            // If dt is too high (e.g. > 4), pretend it's just 1 frame
            const safeDt = Math.min(dt, 4);

            update(safeDt);
            draw();
            animationFrameId = requestAnimationFrame(loop);
        }

    </script>
</body>

</html>